package main

import (
    "fmt"
)

// При решении использовано
// блокирующее поведение
// канала.
func main1() {
    arr := [...]int{2, 4, 6, 8, 10}
    var sum_of_squares int
    // Создаем небуферизованный канал
    // Канал можно не закрывать - он
    // будет удален GC после того, как
    // у него не останется пользователей.
    squares := make(chan int)

    for i := 0; i < len(arr); i++ {
        // Запускаем горутины пропорционально
        // количеству чисел в массиве (их тут немного
        // так что такой вариант приемлем).
        go func(num int, res chan<- int) {
            res<- num * num
        }(arr[i], squares)
    }
    for j := 0; j < len(arr); j++ {
        // Читаем числа из канала и прибавляем
        // к переменной sum_of_squares.
        // for это синхронная операция, таким
        // образом мы дожидаемся завершения всех 
        // горутин.
        // Мы гарантируем что все результаты горутин
        // будут просуммированы, так как это синхронная операция
        // и чтение из канала мы осуществляем пропорционально
        // запущенным горутинам
        sum_of_squares += <-squares
    }
    fmt.Printf("Sum of squares = %d\n", sum_of_squares)
}
