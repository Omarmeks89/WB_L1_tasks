package main

import (
    "fmt"
    "sync"
)

//
// Решение с использованием WaitGroup
//
func main2() {
    var wg sync.WaitGroup
    arr := [...]int{2, 4, 6, 8, 10}

    //
    // Создаем по одной горутине для каждого значения
    //
    for i := 0; i < len(arr); i++ {
        //
        // Инкрементируем внутренний счетчик,
        //
        wg.Add(1)
        //
        //
        go func(num int, w *sync.WaitGroup) {
            // 
            // Передаем WaitGroup по указателю, так как
            // внутри он содержит мьютекс, который является не копируемым.
            // (Возможность копирования мьютекса привела бы к тому, что у 
            // каждой горутины он был бы свой, что привело бы к состоянию гонки.)
            // Мы можем быть уверены, что обращаемся к одному и тому же примитиву синхр.
            //
            // Планируем декремент счетчика после завершения горутины.
            defer w.Done()
            fmt.Printf("%d\n", num * num)
        }(arr[i], &wg)
    }
    //
    // Ждем пока внутренний счетчик не будет равен 0.
    // Блокируем выполнения главного потока до этого момента,
    // позволяя всем горутинам завершить работу.
    //
    wg.Wait()
}
