## Что выведет программа:

```go
func someAction(v []int8, b int8) {
    v[0] = 100
    v = append(v, b)
}

func main() {
    var a = []int8{1, 2, 3, 4, 5}
    someAction(a, 6)
    fmt.Println(a)
}
```

Результат:

```bash
[100, 2, 3, 4, 5]
```

Мы получили в параметрах функции копию слайса a, но
поскольку указатель внутри структуры слайса (при создании нового
слайса на том же массиве) указывает на ту же облать памяти, мы
можем строкой `v[0] = 100` изменить значения первого элемента
массива.
Далее строкой `v = append(v, b)` мы создаем новый массив и слайс
так как добавление еще одного элемента превысит границы исходного
массива и его нужно будет пересоздать заново (скопировать старое + 
добавить новое) и новый слайс уже будет указывать на новый массив
и значение `6` добавится имеенно в этот вновь созданный слайс, а не 
в исходный. В исходном изменится только значение первого элемента массива.
Новый слайс существует только в области видимости (и фрейме) функции someAction.

Чтобы исправить такое поведение, нужно передать слайс по указателю:

```go
func someAction(v *[]int8, b int8) {
    (*v)[0] = 100
    *v = append(*v, b)
}

func main() {
    var a = []int8{1, 2, 3, 4, 5}
    someAction(&a, 6)
    fmt.Println(a)
}
```

Результат:

```bash
[100, 2, 3, 4, 5, 6]
```

